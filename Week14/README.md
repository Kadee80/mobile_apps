# Data persistence with JSON Server and ngrok

We now have a fully functioning app using Context to store and update our State. The only issue here is there isn't much point in saving notes only to lose them when we close our app! We looked at `JSON Server` as an outside API/database around midterms with React DOM. As per usual when looking to do the same thing with React Native, it's always similar, but different. Instead of our DB existing within our project deployed using Expo, this time it will be it's own project on your computer. We will use `ngrok` to make our server on our computer publicly available on the internet. Why? Because right now, if you are running your app on your physical device, chances are you are communicating via either WiFi or a tunnel between Expo on your computer and Expo on your device. We need to set up a fool proof way to make our database running on our computer available between the 2.

## Setting up JSON Server and ngrok

First, we need to create a separate project for our database. Documentation for [JSON Server can be found here](https://www.npmjs.com/package/json-server).

1. `cd` or `dir` into your current project. Once inside, `cd` / `dir` up one level using `../`. Now your terminal location should be next to, but NOT inside your CRUD app.
2. Now that you are outside of, but next to your current project we are going to make a new directory:

```bash
mkdir jsonserver
```

3. Next, `cd` / `dir` into the new directory:

```bash
cd jsonserver
```

4. Now to generate a new package.json file run:

```bash
npm init
```

5. You will be asked a few questions to generate the file, you can just hit enter over and over again, or you can fill out the description with something more precise when you cocme to that question. Honestly, don't overthink this part because we will not be running our server the way we did around midterms.

6. Now that we have a `package.json` file inside our new project, we can start installing some dependencies:

```bash
npm install json-server ngrok
```

7. We need to do some setup steps for `ngrok` to work correctly. [Sign up for an ngrok account](https://dashboard.ngrok.com/signup). Once you have signed up/in, you should be redirected to a page that shows you how to install, it should also show a command with an access token. Keep this page open! Here is a separate link to [download and install ngrok for your computers OS](https://ngrok.com/download).

8. One `ngrok` is installed. Run the command with your specific token from the the page you we redirected to after signing up/in:

```bash
ngrok config add-authtoken {YOUR_SPECIFIC_TOKEN_HERE}
```

NOTE: You only have to install `ngrok` and configure it for your computer once! So if you decide to use `ngrok` for another project, your token has already been configured globally!

9. Open your new project inside VS Code. Create a new file next to `package.json` called `db.json`.

10. Remember, this `json` file is going to act like our database. We need to add a little buit of configuration. Inside db.json add the following:

```json
{
  "posts": []
}
```

NOTE: What did we just do? We just configured an endpoint to manage a resource named `posts`. If you ever wanted to add another endpoint, you would add it into this object. Remember, this is a `json` file not a javascript object so we need double quotes `"` around our keys.

11. Next, we need to add a script to launch our server inside `package.json`. You can delete any autogenerated scripts within the `"scripts"` object, and then add the following:

```json
  "scripts": {
    "db": "json-server -w db.json",
    "tunnel": "ngrok http 3000"
  },
```

12. Go ahead and save your changes to `package.json` but keep it open. You may need to make a few more config changes to your scripts depending on how the test run goes. Now it's time to run our scripts.

13. Inside terminal open up a second tab/window. Make sure both windows are inside your jsonserver project. Inside the first tab:

```bash
npm run db
```

If you are successful, you should see a few messages about json server running on port 3000. If you see error port in use, that means you ar running another project using port 3000, and you will have to update your port or find and shut down whatever other service was running on 3000.

To update your port:

```json
 "db": "json-server -w db.json -p 3001",
```

If you change your port in one script, you need to make sure you update it to match in the other!

14. Now with that first script running, we can access that server within our local machine, but we want to make it public so that other devices (like our phone) can access it. Enter ngrok

Inside the second window run:

```bash
npm run tunnel
```

If you are successful you should see a message with an emoji and some other info saying forwarding...

15. To the right of that you should se an address of sorts. The address is long and should end with `.ngrok-free.app`. You will probably have to widen your terminal window to see the complete url. You should see a web interface for you JSON Server project with `/posts - 0 item` showing we have nothing stored in our `/posts` yet.

NOTE: each tunnel session only last 8 hours. After that it shuts down. If for some reason you left yours open for a long period of time, you can always kill it with `control + C` and run `npm run tunnel` again for a new session.

_If you restart `ngrok` the url will change! So make sure you copy and paste the new URL into your browser! We will also need to make use of the newer URL inside of our React Native code (don't worry, we will look at how to do that)_

### Quick Start Notes

If you have successfully completed the steps above, to run your project from this point forward you will need 3 terminal windows.

1. `cd`/`dir` into your React Native project: `npm run start` to launch your app and emulator.
2. `cd`/`dir` into jsonserver project: `npm run db` to start your server/database.
3. open a second tab inside your jsonserver project: `npm run tunnel` to open your ngrok tunnel.

Now that we have the setup out of the way, we can start making use of all of this inside of our CRUD app!

## Axios and Network Requests

We will once again be using the `axios` library to make our network requests. In order to use it, we have to first install it.

Make sure you are inside your React Native project folder NOT your `jsonserver` folder:

```bash
npm install axios
```

If you remember from our last project using JSON server, it generates unique IDs for us, so we no longer need to generate them with `Math.random()` inside of our React code.

Here is a quick table of the requests we will be making to our new server and endpoints:

| **Method** | **Route**   | **Result**           |
| ---------- | ----------- | -------------------- |
| GET        | /posts      | gets all posts       |
| GET        | /posts/{id} | gets a post by id    |
| POST       | /posts      | creates a new post   |
| PUT        | /posts/{id} | edits a post by id   |
| DELETE     | /posts/{id} | deletes a post by id |

Remember: The routes above will need the ngrok address in addition to the endpoints listed above. So if we restart our tunnel, we will need to update the base URL inside of our code. If you wish to pay a few bucks a month for `ngrok` you can get a static url that will not change over time, but for this class, free with a small hassel each time works.

Currently our `IndexScreen` looks to the Context Provider for initial state's posts. Something we have seen before.

Our new flow will be:

1. `IndexScreen` mounts
2. `IndexScreen` needs to call a function to GET all posts from our server
3. `IndexScreen` receives a probably empty list while our request is processing...
4. Request is now complete, and the list of posts needs to be stored using our `useReducer` hook.
5. `State` has now changed, which should trigger a rerender and any posts retrieved will render on screen.

### Making our initial request function

Open up your React App project inside VSCode.

Inside your `src/` directory, add a new folder named `api/`.

Add a file inside `api/` called `jsonServer.js`. Inside this file, we are going to make a preconfigured instance of `axios` much like we did with our Yelp Restaurant App.

```js
import axios from 'axios'

export default axios.create({
  // TODO
})
```

We only have one thing to configure here since we do not need to use an API access token. All we need to configure is our `baseURL`. Remember, this will change each time we restart our tunnel!

```js
export default axios.create({
  baseURL:
    'copy and paste from your tunnel terminal window inside string quotes',
})
```

Now inside of our `DiaryContext.js` we will need to import our `axios` instance we just created:

```jsx
import createDataContext from './createDataContext'
import jsonServer from '../api/jsonServer'
...
```

Now we can make use of this axios instance inside of our action functions. We currently are reading our posts directly out of `state` using `useContext`. We do not have an action yet to fetch posts. Let's go ahead and create one. Right above the `addDiaryPost` function add the following:

```jsx
// new action helper to retreive initial posts from our JSON server
const getDiaryPosts = (dispatch) => {
  return () => {
    // coming soon
  }
}
```

We already know that this function is going to take a few milliseconds, so we should flag the inner function as `async` right away:

```jsx
const getDiaryPosts = (dispatch) => {
  return async () => {
    const response = await jsonServer.get('/posts')
    // response.data is where our array of post objects will be!
  }
}
```

Now that we have retrieved our list of posts from our db, we can dispatch an action to update our state. Remember, whenever we dispatch an action, it automatically calls our reducer function and looks for the appropriate `action.type`. We just dispatched a new `action.type`, so we need to add that case to our reducer:

```jsx
const postReducer = (state, action) => {
  switch (action.type) {
    case 'get_posts':
      // return all posts from db to update state
      return action.payload
    case 'add_post':
      ...
```

We did not do any copying of what we already had in state here. That is because our JSON Server DB is our single source of truth regarding posts now. We are not adding, we are replacing state with the response from the DB.

Next up, we need to make sure this function is available to any/all components wrapped in this Provider inside our App. All of the way down at the bottom of the file, find where we are passing an object with all of our actions to our Context Generator function and add the `getDiaryPosts` action creator function to it:

```jsx
export const {Context, Provider} = createDataContext(
  postReducer,
  {
    getDiaryPosts,
    addDiaryPost,
    deleteDiaryPost,
    editDiaryPost,
  },
  [] // we no longer need a dummy post in initial state so delete that if your had one and replace it with an empty array!
)
```

The last thing we need to do, is call `getDiaryPosts` from our `IndexScreen`. First we need to destructure it out to the left of our `useContext(Context)` hook.

```jsx
const IndexScreen = ({navigation}) => {
  const {state, deleteDiaryPost, getDiaryPosts} = useContext(Context)
...
```

Remember, we never call a function that updates our state directly. We need to either add it to an `onPress` event or in this case, call it when the Screen first mounts using `useEffect`;

```jsx
const IndexScreen = ({navigation}) => {
  const {state, deleteDiaryPost, getDiaryPosts} = useContext(Context)

  useEffect(() => {
    getDiaryPosts()
  }, [])

  ...
```

Go ahead and save, if you run your React App, DB, and Tunnel, you should see an empty list on your IndexScreen, that is because we have no posts in our DB yet. We can manually edit our `db.json` file to add in an initial post for now. This is very similar to the initial state we were setting up earlier inside our Context generator.

Inside db.json:

```json
{
  "posts": [
    {
      "id": 1,
      "title": "Manual Entry Post",
      "content": "Some content to fill our screen!"
    }
  ]
}
```

Save the file and reload your app. You should see the manually entered post appear!

If you have issues, it could be a few things. First, check to make sure your terminal running your json server has a message stating that `db.json` has changes. Next, take a look at the base url we copied before. Add `/posts` to the end, and if you do not see your post there as JSON data, you may have an issue with your tunnel.

First step for either of those is to kill and restart the scripts.

Remember, every time you kill your `tunnel` script, you will get a new `baseURL` you will need to copy into your `jsonServer.js` file.

If everything looks OK on the backend, it is most likely that you have a typo or issue in your React Native App code.

## Creating a New Post

Since we are now fetching our existing posts, we need to start adding to them. The next endpoint we will make use of is a POST request to our `/posts` endpoint. To do this we will have to modify our existing `addDiaryPost` action creator helper function. Remember, from here on out, our DB is the source of truth for our posts.

To start, find you `addDiaryPost` helper function, and comment out the inner lines within the returned function:

```jsx
const addDiaryPost = (dispatch) => {
  return (title, content, callback) => {
    // dispatch({type: 'add_post', payload: {title, content}})
    // if (callback) {
    //   callback()
    // }
  }
}
```

Now we can focus on the API request on its own. Remember, this a POST request to the `/posts` endpoint, and we will need to send along the data to create our new post. IDs will be automatically generated by JSON server.

To start, let's add in our axios POST request and flag it as `async`. Remember our second argument is the data we wish to pass on to the server, and since we have identical key value pairs, we can shorten it up:

```jsx
const addDiaryPost = (dispatch) => {
  return async (title, content, callback) => {
    const response = await jsonServer.post('/posts', {title, content})
    // dispatch({type: 'add_post', payload: {title, content}})
    // if (callback) {
    //   callback()
    // }
  }
}
```

At this point we could test the API call by filling out the `CreateScreen` form and hitting the button, but since we have not yet dispatched, or updated our reducer function, the only way to tell if it was successful is to open our `db.json` and see if a second post now exists. If so, we can now refresh our emulator and view this new post on the `IndexScreen`.

Another way to test this, is to uncomment our callback conditional which will run our redirect back to the `IndexScreen` once our response has completed. We should be able to see any newly created posts there AFTER a refresh.

Why dont we see it until a refresh? Because we are not yet re-fetching on a navigate function, and nothing has really updated in State until we do. Technically, our `IndexScreen` is not being destroyed and remounted when we navigate, so our useEffect function does not fire, and therefore nothing updates our State. We need to update our `useEffect` function to also add a new kind of event listener we have not seen before:

```jsx
useEffect(() => {
  getDiaryPosts()
  navigation.addListener('didFocus', () => {})
}, [])
```

This sort of looks like a vanilla js `document.addEventListener('click', () => {})`. The first argument is the event we are listening for and the second is the callback function to fire when that event is detected. To finish this off we can add in another call to `getDiaryPosts` inside our callback. This is not fully complete, but it is enough to do an intial test:

```jsx
useEffect(() => {
  // on mount
  getDiaryPosts()
  // any time a user navigates back to this screen again
  navigation.addListener('didFocus', () => {
    getDiaryPosts()
  })
}, [])
```

So it works. What's missing? Well whenever we add an event listener, we usually need a cleanup function to make sure we arent adding the same listener over and over again, and certainly to make sure the listener is detroyed if and when the `IndexScreen` is destroyed and remounted. No memory leaks here thank you!

```jsx
useEffect(() => {
  getDiaryPosts()

  const listener = navigation.addListener('didFocus', () => {
    getDiaryPosts()
  })
  // to add a cleanup function we can return one here!
  // this is only invoked if the IndexScreen is destroyed
  return () => {
    listener.remove()
  }
}, [])
```

What about the still commented out line in our `addDiaryPost` function? Well, technically, because we are adding the post directly to the DB, and always redirecting back to the `IndexScreen` which fetches ALL of the posts and updates state, we no longer need it. If we wanted, we could even remove this case entirely from our reducer! A similar case will be true for `editDiaryPost`.

## Deleting a Post

In order to delete a post, we need the post's ID in our endpoint: `posts/{id}`. Let's go ahead and update our `deleteDiaryPost` function. We can comment our the `dispatch` line and flag our inner function as `async` and add our new API call.

```jsx
const deleteDiaryPost = (dispatch) => {
  return async (id) => {
    const response = await jsonServer.delete(`/posts/${id}`)
    // dispatch({type: 'delete_post', payload: id})
  }
}
```

So now we are in yet another scenario where we need to fetch our new total list of posts. Delete is called from the `IndexScreen` so our navigation listener wont help us here. We can bring back our dispatch line like so:

```jsx
const deleteDiaryPost = (dispatch) => {
  return async (id) => {
    const response = await jsonServer.delete(`/posts/${id}`)
    dispatch({type: 'delete_post', payload: id})
  }
}
```

## Editing a Post

Last up is `editDiaryPost`. We already have a listener that watches our `IndexScreen`, but when we edit a post, we navigate back to our `ViewScreen`. The solution is to keep our dispatch call, and to only call it after a successful API response.

```jsx
const editDiaryPost = (dispatch) => {
  return async (id, title, content, callback) => {
    // edit the post by ID, don't forget the second argument to update the post title and content
    await jsonServer.put(`/posts/${id}`, {title, content})
    // once the API call is successful, update our state with our reducer
    dispatch({type: 'edit_post', payload: {id, title, content}})
    if (callback) {
      callback()
    }
  }
}
```

We can now test this by editing a post, viewing the `ViewScreen` to see its updated content and then clicking `< back` to see the updated title in our list of posts on our `IndexScreen`.

## Conclusion:

This app introduced some new-ish ideas with a React Native flavor. Just to review, here are some key points:

1. We introduced Context and wrapped our entire App in it's Provider to expose `State` and any action helper functions to any and all components directly.
2. We extracted a generic `createDataContext` function to automate Context creation. This was not exactly neccessary for this small app with once instance of Context but it exposed us to some design patterns we may see at work some day. It also enables us to add more resources with other Contexts quite easily if our Application grows.
3. We used `useReducer` instead of `useState` inside of our Context since all of our actions were updating the same "chunk" of `State`. Plus it exposes us to some design patterns we will someday see at work with `Redux`.
4.
